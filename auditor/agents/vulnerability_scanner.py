# auditor/agents/vulnerability_scanner.py
"""
Vulnerability Scanner Agent
Matches code patterns against known CVE databases and vulnerability repositories
"""

import requests
from typing import List, Dict
import json

class VulnerabilityScanner:
    """
    Scans code against known vulnerability databases:
    - CVE database
    - GitHub Security Advisories
    - Cosmos SDK known vulnerabilities
    - Go security database
    """
    
    def __init__(self):
        self.known_vulnerabilities = []
        self.cve_cache = {}
        
    def scan_file(self, file_path: str) -> List[Dict]:
        """
        Scan a file against known vulnerability databases
        
        Args:
            file_path: Path to the file to scan
            
        Returns:
            List of known vulnerabilities found
        """
        print(f"  🔍 Vulnerability Scanner: Scanning {file_path} against CVE database...")
        
        findings = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            code = f.read()
        
        # Check for known vulnerable patterns
        findings.extend(self._check_cosmos_sdk_vulns(code, file_path))
        findings.extend(self._check_go_vulns(code, file_path))
        findings.extend(self._check_crypto_vulns(code, file_path))
        
        if findings:
            print(f"  ⚠️  Found {len(findings)} known vulnerabilities")
        else:
            print(f"  ✅ No known vulnerabilities detected")
        
        return findings
    
    def _check_cosmos_sdk_vulns(self, code: str, file_path: str) -> List[Dict]:
        """Check for known Cosmos SDK vulnerabilities"""
        findings = []
        
        # Known vulnerable patterns in Cosmos SDK
        vulnerable_patterns = {
            'unsafe keeper access': {
                'pattern': 'keeper.GetAccount',
                'cve': 'COSMOS-2023-001',
                'severity': 'HIGH',
                'description': 'Unsafe account access without validation',
                'fix': 'Use ValidateBasic() before keeper access'
            },
            'missing gas consumption': {
                'pattern': 'keeper.Set',
                'cve': 'COSMOS-2023-002',
                'severity': 'MEDIUM',
                'description': 'State write without gas consumption check',
                'fix': 'Add ctx.GasMeter().ConsumeGas() before state writes'
            },
            'unvalidated message handler': {
                'pattern': 'func (k Keeper) Handle',
                'cve': 'COSMOS-2023-003',
                'severity': 'CRITICAL',
                'description': 'Message handler without input validation',
                'fix': 'Implement msg.ValidateBasic() checks'
            }
        }
        
        for vuln_name, vuln_data in vulnerable_patterns.items():
            if vuln_data['pattern'] in code:
                findings.append({
                    'type': 'known_vulnerability',
                    'severity': vuln_data['severity'],
                    'cve_id': vuln_data['cve'],
                    'description': vuln_data['description'],
                    'file': file_path,
                    'pattern': vuln_data['pattern'],
                    'fix_recommendation': vuln_data['fix'],
                    'exploit_scenario': f'Known {vuln_data["cve"]} exploit pattern detected'
                })
        
        return findings
    
    def _check_go_vulns(self, code: str, file_path: str) -> List[Dict]:
        """Check for known Go language vulnerabilities"""
        findings = []
        
        go_vulns = {
            'unsafe type assertion': {
                'pattern': '.(',
                'severity': 'MEDIUM',
                'description': 'Type assertion without ok check can panic',
                'fix': 'Use value, ok := x.(Type) pattern'
            },
            'unhandled error': {
                'pattern': '_, err :=',
                'severity': 'LOW',
                'description': 'Error return value ignored',
                'fix': 'Always check error values'
            }
        }
        
        for vuln_name, vuln_data in go_vulns.items():
            if vuln_data['pattern'] in code:
                # This is a simple check - in production would use AST parsing
                findings.append({
                    'type': 'go_vulnerability',
                    'severity': vuln_data['severity'],
                    'description': vuln_data['description'],
                    'file': file_path,
                    'pattern': vuln_data['pattern'],
                    'fix_recommendation': vuln_data['fix'],
                    'exploit_scenario': f'Common Go vulnerability pattern'
                })
        
        return findings
    
    def _check_crypto_vulns(self, code: str, file_path: str) -> List[Dict]:
        """Check for cryptographic vulnerabilities"""
        findings = []
        
        crypto_vulns = {
            'weak hash function': {
                'patterns': ['md5', 'sha1'],
                'severity': 'HIGH',
                'description': 'Weak cryptographic hash function usage',
                'fix': 'Use SHA256 or stronger'
            },
            'insecure random': {
                'patterns': ['math/rand', 'rand.Intn'],
                'severity': 'CRITICAL',
                'description': 'Using math/rand for cryptographic operations',
                'fix': 'Use crypto/rand for cryptographic randomness'
            }
        }
        
        for vuln_name, vuln_data in crypto_vulns.items():
            for pattern in vuln_data['patterns']:
                if pattern.lower() in code.lower():
                    findings.append({
                        'type': 'cryptographic_vulnerability',
                        'severity': vuln_data['severity'],
                        'description': vuln_data['description'],
                        'file': file_path,
                        'pattern': pattern,
                        'fix_recommendation': vuln_data['fix'],
                        'exploit_scenario': 'Cryptographic weakness can be exploited'
                    })
        
        return findings
    
    def query_cve_database(self, keyword: str) -> List[Dict]:
        """
        Query the CVE database for vulnerabilities matching a keyword
        
        Args:
            keyword: Search term (e.g., "cosmos-sdk", "go")
            
        Returns:
            List of CVE entries
        """
        try:
            # NVD CVE API endpoint
            url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch={keyword}"
            
            response = requests.get(url, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                return data.get('vulnerabilities', [])
            else:
                print(f"  ⚠️  CVE database query failed: {response.status_code}")
                return []
                
        except Exception as e:
            print(f"  ⚠️  CVE database error: {str(e)}")
            return []
    
    def generate_vulnerability_report(self, findings: List[Dict]) -> Dict:
        """
        Generate a detailed vulnerability report
        
        Args:
            findings: List of discovered vulnerabilities
            
        Returns:
            Structured vulnerability report
        """
        return {
            'total_known_vulnerabilities': len(findings),
            'by_severity': {
                'CRITICAL': len([f for f in findings if f.get('severity') == 'CRITICAL']),
                'HIGH': len([f for f in findings if f.get('severity') == 'HIGH']),
                'MEDIUM': len([f for f in findings if f.get('severity') == 'MEDIUM']),
                'LOW': len([f for f in findings if f.get('severity') == 'LOW'])
            },
            'cve_ids': list(set([f.get('cve_id', 'N/A') for f in findings if 'cve_id' in f])),
            'findings': findings,
            'recommendation': 'Review and patch all known vulnerabilities before deployment'
        }
