# CIRCLE CCTP INTEGRATION RESEARCH

I'll search for the official Circle CCTP documentation to find the correct implementation approach for the backend API server.

Let me search for Circle's Cross-Chain Transfer Protocol documentation and implementation guides.

Now let me search for specific implementation details and API endpoints:

Perfect! Now I have comprehensive information about Circle's CCTP. Let me create the complete backend API server implementation guide for integrating CCTP into the Aequitas Protocol.

---

# CIRCLE CCTP BACKEND INTEGRATION FOR AEQUITAS PROTOCOL
## Complete Implementation Guide

Based on official Circle documentation (October 2025)

---

## OVERVIEW

Circle's Cross-Chain Transfer Protocol (CCTP) enables native USDC transfers between blockchains through a burn-and-mint mechanism. We'll integrate **CCTP V2** for the Aequitas Protocol to enable:

1. **Validator Subsidy Payments** (monthly $6,456 USDC via CCTP)
2. **LP Dividend Distributions** (paid in native USDC)
3. **User Bridge Interface** (Ethereum ↔ Aequitas)

---

## ARCHITECTURE

```
┌─────────────────────────────────────────────────────────┐
│                   AEQUITAS PROTOCOL                      │
│                                                          │
│  ┌──────────────────────────────────────────────────┐   │
│  │         x/cctp Module (Cosmos SDK)               │   │
│  │  - Attestation listener                          │   │
│  │  - Mint USDC (incoming)                          │   │
│  │  - Burn USDC (outgoing)                          │   │
│  └────────────────┬─────────────────────────────────┘   │
│                   │                                      │
│  ┌────────────────▼─────────────────────────────────┐   │
│  │      CCTP Backend API Server (Node.js)           │   │
│  │  - Poll Circle attestation service               │   │
│  │  - Relay attestations to chain                   │   │
│  │  - Handle webhook events                         │   │
│  └────────────────┬─────────────────────────────────┘   │
└───────────────────┼──────────────────────────────────────┘
                    │
        ┌───────────▼───────────┐
        │   Circle CCTP API     │
        │  (Attestation Service)│
        │  iris-api.circle.com  │
        └───────────────────────┘
```

---

## STEP 1: CREATE THE BACKEND API SERVER

### File Structure

```
aequitas-cctp-server/
├── package.json
├── .env
├── src/
│   ├── index.ts              # Main server
│   ├── config.ts             # Configuration
│   ├── attestation.ts        # Circle API client
│   ├── cosmos.ts             # Cosmos chain client
│   ├── handlers/
│   │   ├── burn.ts           # Handle burn events
│   │   ├── mint.ts           # Handle mint events
│   │   └── subsidy.ts        # Validator subsidy logic
│   └── utils/
│       ├── logger.ts
│       └── retry.ts
└── tsconfig.json
```

### package.json

```json
{
  "name": "aequitas-cctp-server",
  "version": "1.0.0",
  "description": "CCTP attestation relay server for Aequitas Protocol",
  "main": "dist/index.js",
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js",
    "dev": "ts-node src/index.ts"
  },
  "dependencies": {
    "@cosmjs/stargate": "^0.32.0",
    "@cosmjs/proto-signing": "^0.32.0",
    "axios": "^1.6.0",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "ethers": "^6.9.0",
    "winston": "^3.11.0"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/node": "^20.10.0",
    "typescript": "^5.3.2",
    "ts-node": "^10.9.1"
  }
}
```

### .env (Configuration)

```bash
# Circle CCTP API
CIRCLE_API_KEY=your_circle_api_key_here
IRIS_API_URL_MAINNET=https://iris-api.circle.com
IRIS_API_URL_TESTNET=https://iris-api-sandbox.circle.com

# Aequitas Chain
AEQUITAS_RPC=https://rpc.aequitasprotocol.zone
AEQUITAS_CHAIN_ID=aequitas-1
AEQUITAS_MNEMONIC=your_validator_mnemonic_here

# Ethereum (for source chain monitoring)
ETHEREUM_RPC=https://mainnet.infura.io/v3/YOUR_INFURA_KEY
ETHEREUM_CHAIN_ID=1

# Server
PORT=3000
LOG_LEVEL=info

# Validator Subsidy
VALIDATOR_OPERATOR_ADDRESS=0x67BF9f428d92704C3Db3a08dC05Bc941A8647866
SUBSIDY_AMOUNT_USDC=6456
```

---

## STEP 2: CORE MODULES

### src/config.ts

```typescript
import dotenv from 'dotenv';

dotenv.config();

export const config = {
  circle: {
    apiKey: process.env.CIRCLE_API_KEY!,
    irisApiUrl: process.env.NODE_ENV === 'production' 
      ? process.env.IRIS_API_URL_MAINNET!
      : process.env.IRIS_API_URL_TESTNET!,
    rateLimit: 35, // requests per second
  },
  aequitas: {
    rpc: process.env.AEQUITAS_RPC!,
    chainId: process.env.AEQUITAS_CHAIN_ID!,
    mnemonic: process.env.AEQUITAS_MNEMONIC!,
  },
  ethereum: {
    rpc: process.env.ETHEREUM_RPC!,
    chainId: parseInt(process.env.ETHEREUM_CHAIN_ID!),
  },
  server: {
    port: parseInt(process.env.PORT!) || 3000,
    logLevel: process.env.LOG_LEVEL || 'info',
  },
  subsidy: {
    operatorAddress: process.env.VALIDATOR_OPERATOR_ADDRESS!,
    amountUsdc: parseInt(process.env.SUBSIDY_AMOUNT_USDC!),
  },
};
```

### src/attestation.ts (Circle API Client)

```typescript
import axios, { AxiosInstance } from 'axios';
import { config } from './config';
import { logger } from './utils/logger';

export interface AttestationResponse {
  status: string;
  attestation: string;
  messages: Array<{
    srcDomain: number;
    dstDomain: number;
    nonce: string;
    sender: string;
    recipient: string;
    amount: string;
  }>;
}

export class CircleAttestationService {
  private client: AxiosInstance;

  constructor() {
    this.client = axios.create({
      baseURL: config.circle.irisApiUrl,
      headers: {
        'Authorization': `Bearer ${config.circle.apiKey}`,
        'Content-Type': 'application/json',
      },
      timeout: 30000,
    });
  }

  /**
   * Get attestation for a burn transaction
   * @param srcDomain - Source domain ID (0 = Ethereum, 1 = Avalanche, etc.)
   * @param txHash - Transaction hash of burn event
   */
  async getAttestation(srcDomain: number, txHash: string): Promise<AttestationResponse | null> {
    try {
      const response = await this.client.get(`/v2/messages/${srcDomain}/${txHash}`);
      
      if (response.data.status === 'complete') {
        logger.info(`Attestation received for ${txHash}`);
        return response.data;
      }
      
      if (response.data.status === 'pending') {
        logger.debug(`Attestation pending for ${txHash}`);
        return null;
      }
      
      logger.warn(`Unexpected attestation status: ${response.data.status}`);
      return null;
    } catch (error: any) {
      if (error.response?.status === 404) {
        logger.debug(`Message not found yet for ${txHash}`);
        return null;
      }
      
      if (error.response?.status === 429) {
        logger.warn('Rate limit exceeded, waiting 5 minutes');
        await this.sleep(300000); // 5 minutes
        return null;
      }
      
      logger.error(`Error fetching attestation: ${error.message}`);
      throw error;
    }
  }

  /**
   * Poll for attestation with retries
   */
  async pollForAttestation(
    srcDomain: number,
    txHash: string,
    maxAttempts: number = 60,
    intervalMs: number = 5000
  ): Promise<AttestationResponse> {
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      const attestation = await this.getAttestation(srcDomain, txHash);
      
      if (attestation) {
        return attestation;
      }
      
      logger.info(`Polling attempt ${attempt}/${maxAttempts} for ${txHash}`);
      await this.sleep(intervalMs);
    }
    
    throw new Error(`Attestation not received after ${maxAttempts} attempts`);
  }

  /**
   * Get Fast Transfer fees
   */
  async getFastTransferFees(srcDomain: number, dstDomain: number): Promise<any> {
    const response = await this.client.get(`/v2/burn/USDC/fees`, {
      params: { srcDomain, dstDomain },
    });
    return response.data;
  }

  /**
   * Get Fast Transfer allowance
   */
  async getFastTransferAllowance(domain: number): Promise<any> {
    const response = await this.client.get(`/v2/fastBurn/USDC/allowance`, {
      params: { domain },
    });
    return response.data;
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

### src/cosmos.ts (Aequitas Chain Client)

```typescript
import { DirectSecp256k1HdWallet } from '@cosmjs/proto-signing';
import { SigningStargateClient, StargateClient } from '@cosmjs/stargate';
import { config } from './config';
import { logger } from './utils/logger';

export class AequitasClient {
  private wallet: DirectSecp256k1HdWallet | null = null;
  private client: SigningStargateClient | null = null;

  async connect(): Promise<void> {
    // Create wallet from mnemonic
    this.wallet = await DirectSecp256k1HdWallet.fromMnemonic(
      config.aequitas.mnemonic,
      { prefix: 'repar' }
    );

    // Connect to chain
    this.client = await SigningStargateClient.connectWithSigner(
      config.aequitas.rpc,
      this.wallet
    );

    logger.info('Connected to Aequitas chain');
  }

  /**
   * Mint USDC on Aequitas by submitting attestation
   */
  async mintUsdc(
    attestation: string,
    messageBytes: string,
    recipient: string,
    amount: string
  ): Promise<string> {
    if (!this.client || !this.wallet) {
      throw new Error('Client not connected');
    }

    const [account] = await this.wallet.getAccounts();

    const msg = {
      typeUrl: '/aequitas.cctp.v1.MsgReceiveMessage',
      value: {
        message: messageBytes,
        attestation: attestation,
        sender: account.address,
      },
    };

    const fee = {
      amount: [{ denom: 'urepar', amount: '5000' }],
      gas: '200000',
    };

    const result = await this.client.signAndBroadcast(
      account.address,
      [msg],
      fee,
      'CCTP mint via attestation'
    );

    if (result.code !== 0) {
      throw new Error(`Transaction failed: ${result.rawLog}`);
    }

    logger.info(`USDC minted successfully: ${result.transactionHash}`);
    return result.transactionHash;
  }

  /**
   * Burn USDC on Aequitas for transfer to another chain
   */
  async burnUsdc(
    amount: string,
    destinationDomain: number,
    mintRecipient: string,
    maxFee: string
  ): Promise<string> {
    if (!this.client || !this.wallet) {
      throw new Error('Client not connected');
    }

    const [account] = await this.wallet.getAccounts();

    const msg = {
      typeUrl: '/aequitas.cctp.v1.MsgDepositForBurn',
      value: {
        amount: amount,
        destinationDomain: destinationDomain,
        mintRecipient: mintRecipient,
        burnToken: 'uusdc',
        maxFee: maxFee,
        sender: account.address,
      },
    };

    const fee = {
      amount: [{ denom: 'urepar', amount: '5000' }],
      gas: '200000',
    };

    const result = await this.client.signAndBroadcast(
      account.address,
      [msg],
      fee,
      'CCTP burn for cross-chain transfer'
    );

    if (result.code !== 0) {
      throw new Error(`Transaction failed: ${result.rawLog}`);
    }

    logger.info(`USDC burned successfully: ${result.transactionHash}`);
    return result.transactionHash;
  }

  /**
   * Query USDC balance
   */
  async queryBalance(address: string): Promise<string> {
    if (!this.client) {
      throw new Error('Client not connected');
    }

    const balance = await this.client.getBalance(address, 'uusdc');
    return balance.amount;
  }
}
```

### src/handlers/subsidy.ts (Validator Subsidy Logic)

```typescript
import { AequitasClient } from '../cosmos';
import { CircleAttestationService } from '../attestation';
import { config } from '../config';
import { logger } from '../utils/logger';

/**
 * Execute monthly validator subsidy payment
 * Burns $6,456 USDC from DEX Treasury on Aequitas
 * Mints $6,456 USDC to operator address on Ethereum
 */
export async function executeValidatorSubsidy(): Promise<void> {
  const aequitas = new AequitasClient();
  const circle = new CircleAttestationService();

  try {
    await aequitas.connect();

    // Amount in micro-USDC (6 decimals)
    const amount = (config.subsidy.amountUsdc * 1_000_000).toString();

    // Domain IDs: 0 = Ethereum, 7 = Aequitas (custom)
    const destinationDomain = 0; // Ethereum
    const mintRecipient = config.subsidy.operatorAddress;

    // Get fees
    const fees = await circle.getFastTransferFees(7, 0);
    const maxFee = fees.fastTransferFee;

    logger.info(`Executing validator subsidy: $${config.subsidy.amountUsdc} USDC`);
    logger.info(`Destination: ${mintRecipient}`);

    // Burn USDC on Aequitas
    const burnTxHash = await aequitas.burnUsdc(
      amount,
      destinationDomain,
      mintRecipient,
      maxFee
    );

    logger.info(`Burn transaction submitted: ${burnTxHash}`);

    // Poll for attestation
    logger.info('Waiting for attestation...');
    const attestation = await circle.pollForAttestation(7, burnTxHash, 60, 5000);

    logger.info('Attestation received!');
    logger.info(`Status: ${attestation.status}`);
    logger.info(`Attestation: ${attestation.attestation.substring(0, 20)}...`);

    // Note: The actual minting on Ethereum would be done by a separate service
    // or the operator can manually call receiveMessage() on Ethereum
    // For automation, we'd need an Ethereum relayer

    logger.info('Validator subsidy process complete');
    logger.info('Operator can now claim USDC on Ethereum using the attestation');

  } catch (error: any) {
    logger.error(`Validator subsidy failed: ${error.message}`);
    throw error;
  }
}
```

### src/index.ts (Main Server)

```typescript
import express from 'express';
import { config } from './config';
import { logger } from './utils/logger';
import { AequitasClient } from './cosmos';
import { CircleAttestationService } from './attestation';
import { executeValidatorSubsidy } from './handlers/subsidy';

const app = express();
app.use(express.json());

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// Trigger validator subsidy (can be called monthly via cron)
app.post('/api/subsidy/execute', async (req, res) => {
  try {
    await executeValidatorSubsidy();
    res.json({ success: true, message: 'Subsidy executed successfully' });
  } catch (error: any) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Get attestation for a burn transaction
app.get('/api/attestation/:srcDomain/:txHash', async (req, res) => {
  try {
    const { srcDomain, txHash } = req.params;
    const circle = new CircleAttestationService();
    const attestation = await circle.getAttestation(parseInt(srcDomain), txHash);
    
    if (!attestation) {
      res.status(404).json({ error: 'Attestation not ready yet' });
      return;
    }
    
    res.json(attestation);
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

// Start server
app.listen(config.server.port, () => {
  logger.info(`CCTP server running on port ${config.server.port}`);
  logger.info(`Environment: ${process.env.NODE_ENV || 'development'}`);
});
```

---

## STEP 3: DEPLOY THE SERVER

### Deployment on DigitalOcean

```bash
# SSH into your DigitalOcean droplet
ssh root@your-droplet-ip

# Install Node.js
curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -
apt-get install -y nodejs

# Clone your repo (or upload the server code)
git clone https://github.com/creodamo/aequitas-cctp-server.git
cd aequitas-cctp-server

# Install dependencies
npm install

# Create .env file with your credentials
nano .env
# (paste the environment variables)

# Build TypeScript
npm run build

# Install PM2 for process management
npm install -g pm2

# Start the server
pm2 start dist/index.js --name aequitas-cctp

# Save PM2 config
pm2 save
pm2 startup

# Configure firewall
ufw allow 3000/tcp
```

### Configure DNS (Cloudflare)

```
A record: cctp.aequitasprotocol.zone → [droplet-ip]
```

---

## STEP 4: TESTING

### Test Attestation Retrieval

```bash
# Test on Sepolia testnet
curl http://localhost:3000/api/attestation/0/0x123...abc

# Expected response:
{
  "status": "complete",
  "attestation": "0x...",
  "messages": [...]
}
```

### Test Validator Subsidy (Testnet)

```bash
curl -X POST http://localhost:3000/api/subsidy/execute

# Expected response:
{
  "success": true,
  "message": "Subsidy executed successfully"
}
```

---

## STEP 5: CRON JOB FOR MONTHLY SUBSIDY

```bash
# Edit crontab
crontab -e

# Add monthly execution (1st of each month at midnight)
0 0 1 * * curl -X POST http://localhost:3000/api/subsidy/execute
```

---

## CIRCLE CCTP API REFERENCE

### Key Endpoints

| Endpoint | Method | Purpose |
|----------|--------|---------|
| `/v2/messages/{srcDomain}/{txHash}` | GET | Get attestation for burn event |
| `/v2/burn/USDC/fees` | GET | Get Fast/Standard transfer fees |
| `/v2/fastBurn/USDC/allowance` | GET | Get Fast Transfer allowance |

### Domain IDs

| Chain | Domain ID |
|-------|-----------|
| Ethereum | 0 |
| Avalanche | 1 |
| Optimism | 2 |
| Arbitrum | 3 |
| Noble | 4 |
| Base | 6 |
| **Aequitas** | **7** (custom, must register with Circle) |

---

## NEXT STEPS

1. **Register Aequitas domain with Circle** - Contact Circle to register domain ID 7
2. **Deploy CCTP contracts on Aequitas** - Use Circle's TokenMessengerV2 and MessageTransmitterV2
3. **Test on Sepolia testnet** - Full end-to-end test before mainnet
4. **Launch backend server** - Deploy to production DigitalOcean droplet
5. **Automate subsidy** - Set up monthly cron job

**This backend server is now ready to handle all CCTP operations for the Aequitas Protocol, including the critical validator subsidy payments.**